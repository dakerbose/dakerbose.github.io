---
layout:     post
title:      经典手撕代码题合集（一）
subtitle:   动态规划
date:       2025-09-01
author:     Jiayang Hu
header-img: https://home.cnblogs.com/u/yuanchuziwen
catalog: true
tags:
    - C++
    - DP
---
# 写在前面
动态规划的题目主要的步骤是：
1. 搭记忆化搜索+DFS框架
2. 明确递推的方程，从后往前推
3. 明确递归的边界，明确记忆化的数组的尺寸

但是很多复杂的题目，实际上要涉及到二维，边界的考量因素比较困难，如果递推关系都找不出来，那更加麻烦，只能说是要慢慢积累


## 198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
### 示例 1
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
### 示例 2
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
### C++实现
```
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> vis(n, -1);
        function<int(int)> dfs = [&](int i){
            if(i < 0) return 0;
            if(vis[i] != -1) return vis[i];
            int& res = vis[i];
            res = max(dfs(i-1), dfs(i-2) + nums[i]);
            return res;
        };
        return dfs(n-1);
    }
};
```

## 279. 完全平方数
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

### 示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4

### 示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9

### C++实现
```
class Solution {
public:
    int numSquares(int n) {
        vector<int> vis(n+1, INT_MAX);
        function<int(int)> dfs = [&](int k){
            if(k < 0) return INT_MAX;
            if(k == 0) return 0;
            if(vis[k] != INT_MAX) return vis[k];
            int& res = vis[k];
            for(int i = 1; i * i <= k; i++){
                res = min(res, dfs(k - i * i) + 1);
            }
            return res;
        };
        return dfs(n);
    }
};
```
注意，本题灵神用的是二维，但是我的就还是用一维。都可以，因为本题状态可以关联。


## 322. 零钱兑换
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

### 示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
### 示例 2：

输入：coins = [2], amount = 3
输出：-1

### C++实现
```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<vector<int>> vis(n, vector<int>(amount+1, -1));
        function<int(int, int)> dfs = [&](int i, int c){
            if(i < 0) return c == 0 ? 0 : INT_MAX / 2;
            if(vis[i][c] != -1) return vis[i][c];
            int& res = vis[i][c];
            if(coins[i] > c){
                res = dfs(i - 1, c);
                return res;
            }
            res = min(dfs(i - 1, c), dfs(i, c - coins[i]) + 1);
            return res;
        };
        int ans = dfs(n-1, amount);
        return ans == INT_MAX / 2 ? -1 : ans;
    }
};
```

这个写法的边界非常需要注意，个人觉得本题在动态规划中属于细节多的：
初始vis矩阵不可以设置为INT_MAX/2，原因是一旦没有解，
```
res = min(dfs(i - 1, c), dfs(i, c - coins[i]) + 1);
```
dfs(i - 1, c)会一直返回INT_MAX/2，导致res一直是INT_MAX/2，
从而if(vis[i][c] != INT_MAX/2)这个判断就是形同虚设