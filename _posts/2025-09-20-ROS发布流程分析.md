---
layout:     post
title:      图论算法加强版
subtitle:   迪杰斯特拉
date:       2025-09-09
author:     Jiayang Hu
header-img: https://home.cnblogs.com/u/yuanchuziwen
catalog: true
tags:
    - dijkstra
---


# ROS订阅调用的语句逻辑

1. 从显式调用层面理解订阅逻辑
   
经典的cpp-ros调用是如下所示的
```cpp
subscriber = nh.subscribe("chatter", 10, &MyNode::cb, this);
```

而不是显示的调用下面的方式
```cpp
subscriber = nh.subscribe<std_msgs::String, MyNode>("chatter", 10, &MyNode::cb, this);
```

编译器就会自动挑选合适的重载并推导出模板参数，不需要手写 <M, T>，具体原理在于(T::*fp)(M)

```cpp
template<class M, class T>
Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, const TransportHints& transport_hints = TransportHints())
{
  SubscribeOptions ops;
  ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, boost::placeholders::_1));
  ops.transport_hints = transport_hints;
  return subscribe(ops);
}
```

**这个东西会根据&MyNode::cb推导出T就是MyNode**

假如说回调函数长这样

```cpp
void MyNode::cb(const std_msgs::String::ConstPtr& msg) {
    ROS_INFO("recv: %s", msg->data.c_str());
}
```
那么M就是 M = std_msgs::String::ConstPtr

(更精确地说，ROS 实际里常用 const boost::shared_ptr<const std_msgs::String>& 之类的签名，源码里有一层模板包装，可以查看第三节内容)

2. 订阅底层通用模板介绍

通用模板如下

```cpp
Subscriber NodeHandle::subscribe(SubscribeOptions& ops)
{
  ops.topic = resolveName(ops.topic);
  if (ops.callback_queue == 0)
  {
    if (callback_queue_)
    {
      ops.callback_queue = callback_queue_;
    }
    else
    {
      ops.callback_queue = getGlobalCallbackQueue();
    }
  }

  if (TopicManager::instance()->subscribe(ops))
  {
    Subscriber sub(ops.topic, *this, ops.helper);

    {
      boost::mutex::scoped_lock lock(collection_->mutex_);
      collection_->subs_.push_back(sub.impl_);
    }

    return sub;
  }

  return Subscriber();
}

```

- resolveName函数的作用：

将用户写的相对名称（可能包含 ~、相对命名空间）解析成全限定 ROS 名称。
这样内部统一使用 fully qualified name，避免命名冲突。resolveName 会参考：

- 当前 NodeHandle 的 namespace
- remapping 规则
- private (~) / relative / global (/) 名称规范


3. SubscribeOptions介绍
这个是一个类，但是是用struct的
具体函数是

- initByFullCallbackType用于确定初始化的回调函数类型
  
```cpp
  template<class P>
  void initByFullCallbackType(const std::string& _topic, uint32_t _queue_size,
       const boost::function<void (P)>& _callback,
       const boost::function<boost::shared_ptr<typename ParameterAdapter<P>::Message>(void)>& factory_fn = DefaultMessageCreator<typename ParameterAdapter<P>::Message>())
  {
    typedef typename ParameterAdapter<P>::Message MessageType;
    topic = _topic;
    queue_size = _queue_size;
    md5sum = message_traits::md5sum<MessageType>();
    datatype = message_traits::datatype<MessageType>();
    helper = boost::make_shared<SubscriptionCallbackHelperT<P> >(_callback, factory_fn);
  }
```
